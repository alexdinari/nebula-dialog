<!--
@license
Copyright (c) 2017 Ars Nebula LLC.
This code may be used under the terms found in LICENSE.md of this repository.
-->

<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../nebula-element-mixin/nebula-element-mixin.html">

<script>
(function() {
  window.Nebula = window.Nebula || {}

  /**
  * Symbols for private methods and properties.
  */
  const onTransitionEnd = Symbol()
  const onClick = Symbol()
  const onKeyDown = Symbol()
  const onOpenedChanged = Symbol()
  const opened = Symbol()
  const isAppended = Symbol()
  const activeElement = Symbol()

  const KEY_ESC = 27

  /**
  * `Nebula.DialogBehavior` is a Polymer behavior to support building custom dialog elements.
  *
  * ## Usage
  * 
  * Add the behavior to you own element. The behavior includes properties, events, and methods for opening, closing and canceling the dialog. The `result` property can be used to define a set of values that identify how the dialog was closed. You need to set this property to meet the needs of your dialog element.
  *
  * ```js
  * Polymer({
  *   is: 'my-dialog',
  *   behaviors: [
  *     Nebula.DialogBehavior
  *   ]
  * })
  * ```
  *
  * ## Style
  *
  * The behavior can be used with custom styles defined in `nebula-dialog-styles`. Import these styles into your custom dialog element to automatically style the element as a backdrop with animation.
  *
  * ```html
  * <style include="nebula-dialog-styles"></style>
  * ```
  *
  * @polymerBehavior
  * @demo demo/index.html
  */
  Nebula.DialogBehavior = Polymer.dedupingMixin(function(base) {
    return class extends Nebula.ElementMixin(base) {
      
      static get properties() {
        return {
          /**
          * Indicates if the dialog can be canceled.
          * If enabled, dialogs can be cancelled by clicking the backdrop or pressing the ESC key.
          */
          allowCancel: {
            type: Boolean,
            value: true
          },

          /**
          * Indicates if the dialog is open.
          */
          opened: {
            type: Boolean,
            reflectToAttribute: true,
            notify: true,
            value: false
          },

          /**
          * A value indicating how the dialog was closed.
          * If the dialog was cancelled, the value will be `undefined`.
          */
          result: {
            type: Object,
            notify: true
          }          
        }
      }

      ready() {
        super.ready()
        this.setAttribute('role', 'alert')
        this.observe('opened',  this[onOpenedChanged])
        this.listen(this, 'click', this[onClick])
        this.listen(this, 'transitionend', this[onTransitionEnd])
      }

      /**
      * Lifecycle handler triggered when a key is pressed down.
      * The handler is added and removed automatically when a element is opened and closed.
      */ 
      [onKeyDown](e) {
        var key = e.keyCode || e.which
        if (key === KEY_ESC && this.allowCancel) {
          e.preventDefault()
          this.cancel()
        }
      }

      /**
      * Event handler triggered when the user taps the base element backdrop.
      * The element is automatically closed.
      */
      [onClick](e) {
        if (this.tagName === e.target.tagName && this.allowCancel) {
          e.preventDefault()
          e.stopPropagation()
          this.cancel()
        }
      }

      /**
      * Event handler triggered when opening and closing animation is complete.
      */
      [onTransitionEnd](e) {
        if (e.propertyName === 'opacity') {
          if (this.opened) {
            this.fire('opened')
          } else {
            this.fire('closed')
          }
        }
      }

      /**
      * Property observer triggered when the value of `opened` is changed.
      */
      [onOpenedChanged](opened) {
        if (opened === void(0)) return
        if (opened) {
          this[activeElement] = document.activeElement
          this.set('result', void(0))
          this.listen(document.body, 'keydown', this[onKeyDown])
        } else {
          if (this[activeElement]) {
            this[activeElement].focus()
            delete this[activeElement]
          }
          this.unlisten(document.body, 'keydown')
        }
      }

      /**
      * Cancels the element.
      * The result is set to `undefined`.
      */
      cancel() {
        if (this.opened) {
          this.setProperties({
            result: void(0),
            opened: false
          })
        }
      }

      /**
      * Closes the dialog with the specified result.
      */
      close(result) {
        if (this.opened) {
          this.setProperties({
            result: result,
            opened: false
          })
        }
      }

      /**
      * Displays the element.
      * A promise is returned that will resolve when the element has been closed.
      */
      show() {
        return new Promise((resolve) => {
          // add element to document body if not parent
          if (!this.parentNode) {
            this[isAppended] = true
            document.body.appendChild(this)
          }

          // listen for our own closed event and resolve promise
          const handler = () => {
            this.unlisten(this, 'closed')
            if (this[isAppended]) {
              this[isAppended] = false
              document.body.removeChild(this)
            }
            resolve(this.result) 
          }
          this.listen(this, 'closed', handler)

          // open the element in a timeout closure to accomodate for animation
          // when appending new element
          setTimeout(() => {
            this.set('opened', true)
          })
        })
      } 

      /**
      * Event triggered when element opening animation is complete.
      * @event opened
      */

      /**
      * Event triggered when element closing animation is complete.
      * @event closed
      */
    }

  })
}())
</script>
